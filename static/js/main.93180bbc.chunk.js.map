{"version":3,"sources":["redux/state/settings/reducer.ts","redux/state/waypoints/reducer.ts","redux/state/index.ts","redux/index.ts","redux/state/settings/selectors.ts","redux/state/waypoints/selectors.ts","redux/state/waypoints/actions.ts","redux/state/settings/actions.ts","style.ts","components/Map/style.ts","components/Map/Map.tsx","components/AppBar/AppBar.tsx","components/Sidebar/Sidebar.tsx","components/ApiKeyDialog/ApiKeyDialog.tsx","components/AddWaypointDialog/AddWaypointDialog.tsx","App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx","redux/state/waypoints/types.ts","redux/state/settings/types.ts","redux/types.ts"],"names":["settingsInitialState","apiKey","getIsApiLoaded","isLoading","waypointsInitialState","waypoints","pairRoutes","optimalPath","settingsPersistConfig","key","storage","stateReconciler","autoMergeLevel2","blacklist","rootReducer","combineReducers","settings","persistReducer","state","action","type","API_KEY_CHANGED","payload","API_LOADED","APP_STARTED_LOADING","APP_FINISHED_LOADING","WAYPOINT_ADDED","id","waypoint","WAYPOINT_REMOVED","updatedWaypoints","Object","keys","PAIR_ROUTES_UPDATED","OPTIMAL_PATH_UPDATED","WAYPOINTS_CLEARED","persistConfig","store","createStore","composeWithDevTools","applyMiddleware","thunk","persistor","persistStore","getSettings","getApiKey","createSelector","getIsAppLoading","getWaypointsState","getWaypoints","waypointsState","getPairRoutes","getOptimalPath","updatePairRoutesWithVerify","dispatch","getState","updatePairRoutes","allPresent","forEach","id1","id2","setPairRouteIfSmaller","route","travelDuration","computePairRoute","w1","w2","timeout","directionService","google","maps","DirectionsService","origin","lat","lng","destination","travelMode","TravelMode","WALKING","response","status","setTimeout","routes","distance","legs","value","duration","travelType","TravelType","Walking","pathCoords","overview_path","map","TRANSIT","transitResponse","transitStatus","transitRoute","transitDuration","PublicTransport","optimalPathRecursion","usedWaypoints","length","i","path","bestDuration","Infinity","bestPath","entries","includes","finish","GlobalStyle","createGlobalStyle","MapContainer","styled","div","WaypointElement","WalkingRouteElement","TransportRouteElement","connect","createStructuredSelector","googleMapProps","bootstrapURLKeys","defaultCenter","defaultZoom","allPathCoords","values","pairRoute","x","optimalPathCoords","coords","push","uuidv4","text","name","AppBar","onMenuButtonClick","onSearchButtonClick","onKeyButtonClick","onAddButtonClick","color","Toolbar","IconButton","edge","onClick","Menu","Typography","variant","style","flex","CircularProgress","Search","VpnKey","Add","formatSeconds","seconds","hours","Math","floor","minutes","clearWaypoints","isVisible","onClose","useState","isClearDialogOpen","setIsClearDialogOpen","waypointList","ListItem","Divider","display","justifyContent","alignItems","width","Drawer","anchor","open","height","List","Button","Dialog","DialogTitle","DialogContent","DialogContentText","DialogActions","setApiKey","isOpen","enteredApiKey","setEnteredApiKey","useEffect","fullWidth","TextField","onChange","e","target","placeholder","disabled","window","location","reload","addWaypointAndUpdatePairRoutes","addWaypoint","index","enteredName","setEnteredName","enteredCoords","setEnteredCoords","isStart","setIsStart","isFinish","setIsFinish","label","FormControlLabel","control","Checkbox","checked","uuid","parseFloat","split","start","theme","createMuiTheme","palette","primary","main","orange","isApiLoaded","setApiLoaded","findOptimalPath","startWaypoint","isSidebarVisible","setIsSidebarVisible","isApiKeyDialogOpen","setIsApiKeyDialogOpen","isAddWaypointDialogVisible","setIsAddWaypointDialogVisible","Loader","load","then","ThemeProvider","CssBaseline","Boolean","hostname","match","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","loading","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.93180bbc.chunk.js","sourcesContent":["import { SettingsState, SettingsAction, API_KEY_CHANGED, API_LOADED, APP_STARTED_LOADING, APP_FINISHED_LOADING } from './types';\r\n\r\nconst settingsInitialState: SettingsState = {\r\n    apiKey: null,\r\n    getIsApiLoaded: false,\r\n    isLoading: false,\r\n};\r\n\r\nexport const settingsReducer = (state = settingsInitialState, action: SettingsAction) => {\r\n    switch (action.type) {\r\n        case API_KEY_CHANGED:\r\n            return { ...state, ...action.payload };\r\n\r\n        case API_LOADED:\r\n            return { ...state, getIsApiLoaded: true };\r\n\r\n        case APP_STARTED_LOADING:\r\n            return { ...state, isLoading: true };\r\n\r\n        case APP_FINISHED_LOADING:\r\n            return { ...state, isLoading: false };\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n","import {\r\n    WaypointsState,\r\n    WaypointsAction,\r\n    WAYPOINT_ADDED,\r\n    WAYPOINT_REMOVED,\r\n    PAIR_ROUTES_UPDATED,\r\n    OPTIMAL_PATH_UPDATED,\r\n    WAYPOINTS_CLEARED,\r\n} from './types';\r\n\r\nexport const waypointsInitialState: WaypointsState = {\r\n    waypoints: {},\r\n    pairRoutes: {},\r\n    optimalPath: [],\r\n};\r\n\r\nexport const waypointsReducer = (state = waypointsInitialState, action: WaypointsAction) => {\r\n    switch (action.type) {\r\n        case WAYPOINT_ADDED:\r\n            return { ...state, waypoints: {\r\n                ...state.waypoints,\r\n                [action.payload.id]: action.payload.waypoint,\r\n            } };\r\n\r\n        case WAYPOINT_REMOVED:\r\n            const updatedWaypoints = { ...state.waypoints };\r\n\r\n            if (action.payload.id in Object.keys(updatedWaypoints)) {\r\n                delete updatedWaypoints[action.payload.id];\r\n            }\r\n\r\n            return { ...state, waypoints: updatedWaypoints };\r\n\r\n        case PAIR_ROUTES_UPDATED:\r\n        case OPTIMAL_PATH_UPDATED:\r\n            return { ...state, ...action.payload };\r\n\r\n        case WAYPOINTS_CLEARED:\r\n            return { ...waypointsInitialState };\r\n\r\n        default:\r\n            return state;\r\n    };\r\n};\r\n","import { combineReducers } from 'redux';\r\nimport { persistReducer } from 'redux-persist';\r\nimport storage from 'redux-persist/lib/storage';\r\nimport autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';\r\nimport { settingsReducer } from './settings/reducer';\r\nimport { waypointsReducer } from './waypoints/reducer';\r\n\r\nconst settingsPersistConfig = {\r\n    key: 'settings',\r\n    storage,\r\n    stateReconciler: autoMergeLevel2,\r\n    blacklist: ['getIsApiLoaded'],\r\n};\r\n\r\nexport const rootReducer = combineReducers({\r\n    settings: persistReducer(settingsPersistConfig, settingsReducer),\r\n    waypoints: waypointsReducer,\r\n});\r\n","import thunk from 'redux-thunk';\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport { composeWithDevTools } from 'redux-devtools-extension';\r\nimport { persistStore, persistReducer } from 'redux-persist';\r\nimport storage from 'redux-persist/lib/storage';\r\nimport autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';\r\nimport { Action, State } from './state/types';\r\nimport { rootReducer } from './state';\r\n\r\nconst persistConfig = {\r\n    key: 'root',\r\n    storage,\r\n    stateReconciler: autoMergeLevel2,\r\n    blacklist: ['settings'],\r\n};\r\n\r\nexport const store = createStore(\r\n    persistReducer<State, Action>(persistConfig, rootReducer as any),\r\n    composeWithDevTools(applyMiddleware(thunk)),\r\n);\r\n\r\nexport const persistor = persistStore(store as any);\r\n","import { createSelector } from 'reselect';\r\nimport { State } from '../types';\r\nimport { SettingsState } from './types';\r\n\r\nexport const getSettings = (state: State) => state.settings;\r\n\r\nexport const getApiKey = createSelector<State, SettingsState, string | null>(\r\n    getSettings,\r\n    settings => settings.apiKey,\r\n);\r\n\r\nexport const getIsApiLoaded = createSelector<State, SettingsState, boolean>(\r\n    getSettings,\r\n    settings => settings.getIsApiLoaded,\r\n);\r\n\r\nexport const getIsAppLoading = createSelector(\r\n    getSettings,\r\n    settings => settings.isLoading,\r\n);\r\n","import { createSelector } from 'reselect';\r\nimport { State } from '../types';\r\n\r\nexport const getWaypointsState = (state: State) => state.waypoints;\r\n\r\nexport const getWaypoints = createSelector(\r\n    getWaypointsState,\r\n    waypointsState => waypointsState.waypoints,\r\n);\r\n\r\nexport const getPairRoutes = createSelector(\r\n    getWaypointsState,\r\n    waypointsState => waypointsState.pairRoutes,\r\n);\r\n\r\nexport const getOptimalPath = createSelector(\r\n    getWaypointsState,\r\n    waypointsState => waypointsState.optimalPath,\r\n);\r\n","import { AppThunkAction } from '../types';\r\nimport { getIsApiLoaded } from '../settings/selectors';\r\nimport {\r\n    WaypointAddedAction,\r\n    WaypointRemovedAction,\r\n    PairRoutesUpdatedAction,\r\n    OptimalPathUpdatedAction,\r\n    WaypointsClearedAction,\r\n    WAYPOINT_ADDED,\r\n    WAYPOINT_REMOVED,\r\n    PAIR_ROUTES_UPDATED,\r\n    OPTIMAL_PATH_UPDATED,\r\n    WAYPOINTS_CLEARED,\r\n    Waypoint,\r\n    PairRoutes,\r\n    PairRoute,\r\n    TravelType,\r\n} from './types';\r\nimport { getPairRoutes, getWaypoints } from './selectors';\r\nimport { appFinishLoading, appStartLoading } from '../settings/actions';\r\n\r\nexport const addWaypoint = (id: string, waypoint: Waypoint): WaypointAddedAction => ({\r\n    type: WAYPOINT_ADDED,\r\n    payload: { id, waypoint },\r\n});\r\n\r\nexport const removeWaypoint = (id: string): WaypointRemovedAction => ({\r\n    type: WAYPOINT_REMOVED,\r\n    payload: { id },\r\n});\r\n\r\nexport const updatePairRoutes = (pairRoutes: PairRoutes): PairRoutesUpdatedAction => ({\r\n    type: PAIR_ROUTES_UPDATED,\r\n    payload: { pairRoutes },\r\n});\r\n\r\nexport const updatePairRoutesWithVerify = (pairRoutes: PairRoutes): AppThunkAction => (dispatch, getState) => {\r\n    const state = getState();\r\n    const waypoints = getWaypoints(state);\r\n\r\n    dispatch(updatePairRoutes(pairRoutes));\r\n\r\n    let allPresent = true;\r\n    Object.keys(waypoints).forEach(id1 => {\r\n        Object.keys(waypoints).forEach(id2 => {\r\n            if (id1 !== id2 && (!pairRoutes[id1] || !pairRoutes[id1][id2])) {\r\n                allPresent = false;\r\n            }\r\n        });\r\n    });\r\n\r\n    if (allPresent) {\r\n        dispatch(appFinishLoading());\r\n    }\r\n};\r\n\r\nexport const updateOptimalPath = (optimalPath: string[]): OptimalPathUpdatedAction => ({\r\n    type: OPTIMAL_PATH_UPDATED,\r\n    payload: { optimalPath },\r\n});\r\n\r\nexport const clearWaypoints = (): WaypointsClearedAction => ({\r\n    type: WAYPOINTS_CLEARED,\r\n});\r\n\r\nexport const setPairRouteIfSmaller = (id1: string, id2: string, route: PairRoute): AppThunkAction => (dispatch, getState) => {\r\n    const pairRoutes = getPairRoutes(getState());\r\n\r\n    if (!pairRoutes[id1] || !pairRoutes[id1][id2] || route.travelDuration < pairRoutes[id1][id2].travelDuration) {\r\n        dispatch(updatePairRoutesWithVerify({\r\n            ...pairRoutes,\r\n            [id1]: {\r\n                ...(pairRoutes[id1] || {}),\r\n                [id2]: route,\r\n            },\r\n        }));\r\n    }\r\n};\r\n\r\nexport const computePairRoute = (id1: string, w1: Waypoint, id2: string, w2: Waypoint, timeout: number): AppThunkAction => dispatch => {\r\n    const directionService = new google.maps.DirectionsService();\r\n\r\n    directionService.route({\r\n        origin: { lat: w1.lat, lng: w1.lng },\r\n        destination: { lat: w2.lat, lng: w2.lng },\r\n        travelMode: google.maps.TravelMode.WALKING,\r\n    }, (response, status) => {\r\n        if (status !== 'OK') {\r\n            setTimeout(() => dispatch(computePairRoute(id1, w1, id2, w2, timeout + 1000)), timeout);\r\n        }\r\n\r\n        if (response && response.routes && response.routes[0]) {\r\n            const route = response.routes[0];\r\n\r\n            const distance = route.legs[0].distance?.value || 100000000;\r\n            const duration = route.legs[0].duration?.value || 100000000;\r\n\r\n            if (distance < 2500) {\r\n                dispatch(setPairRouteIfSmaller(id1, id2, {\r\n                    travelDuration: duration,\r\n                    travelType: TravelType.Walking,\r\n                    pathCoords: route.overview_path.map(({ lat, lng }) => ({ lat: lat(), lng: lng() })),\r\n                }));\r\n            }\r\n\r\n            else {\r\n                setTimeout(() => {\r\n                    directionService.route({\r\n                        origin: { lat: w1.lat, lng: w1.lng },\r\n                        destination: { lat: w2.lat, lng: w2.lng },\r\n                        travelMode: google.maps.TravelMode.TRANSIT,\r\n                    }, (transitResponse, transitStatus) => {\r\n                        if (transitStatus !== 'OK') {\r\n                            setTimeout(() => dispatch(computePairRoute(id1, w1, id2, w2, timeout + 1000)), timeout);\r\n                        }\r\n\r\n                        if (transitResponse && transitResponse.routes && transitResponse.routes[0]) {\r\n                            const transitRoute = transitResponse.routes[0];\r\n\r\n                            const transitDuration = transitRoute.legs[0].duration?.value || 100000000;\r\n\r\n                            dispatch(setPairRouteIfSmaller(id1, id2, {\r\n                                travelDuration: transitDuration,\r\n                                travelType: TravelType.PublicTransport,\r\n                                pathCoords: transitRoute.overview_path.map(({ lat, lng }) => ({ lat: lat(), lng: lng() })),\r\n                            }));\r\n                        }\r\n                    });\r\n                }, 1000);\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nexport const addWaypointAndUpdatePairRoutes = (id: string, waypoint: Waypoint): AppThunkAction => (dispatch, getState) => {\r\n    const state = getState();\r\n\r\n    const isApiLoaded = getIsApiLoaded(state);\r\n\r\n    if (!isApiLoaded) {\r\n        setTimeout(() => {\r\n            dispatch(addWaypointAndUpdatePairRoutes(id, waypoint));\r\n        }, 300);\r\n        return;\r\n    }\r\n\r\n    const waypoints = getWaypoints(state);\r\n\r\n    dispatch(addWaypoint(id, waypoint));\r\n\r\n    if (Object.keys(waypoint).length > 0) {\r\n        dispatch(appStartLoading());\r\n    }\r\n    Object.keys(waypoints).forEach((id2, index) => {\r\n        setTimeout(() => dispatch(computePairRoute(id, waypoint, id2, waypoints[id2], 100)), 1000 * index);\r\n        setTimeout(() => dispatch(computePairRoute(id2, waypoints[id2], id, waypoint, 100)), 1000 * (Object.keys(waypoints).length + index));\r\n    });\r\n};\r\n\r\ninterface OptimalPathRecursionProps {\r\n    pairRoutes: PairRoutes;\r\n    waypoints: Record<string, Waypoint>;\r\n    usedWaypoints: string[];\r\n}\r\n\r\nconst optimalPathRecursion = ({ pairRoutes, waypoints, usedWaypoints }: OptimalPathRecursionProps) => {\r\n    if (usedWaypoints.length === Object.keys(waypoints).length) {\r\n        let duration = 0;\r\n        for (let i = 1; i < usedWaypoints.length; ++i) {\r\n            duration += pairRoutes[usedWaypoints[i - 1]][usedWaypoints[i]].travelDuration;\r\n        }\r\n\r\n        return { duration, path: usedWaypoints };\r\n    }\r\n\r\n    let bestDuration = Infinity;\r\n    let bestPath: string[] = [];\r\n    Object.entries(waypoints).forEach(([id, waypoint]) => {\r\n        if (usedWaypoints.includes(id)) {\r\n            return;\r\n        }\r\n\r\n        if (waypoint.finish && !(usedWaypoints.length === Object.keys(waypoints).length - 1)) {\r\n            return;\r\n        }\r\n\r\n        const { duration, path } = optimalPathRecursion({\r\n            pairRoutes,\r\n            waypoints,\r\n            usedWaypoints: [...usedWaypoints, id],\r\n        });\r\n\r\n        if (duration < bestDuration) {\r\n            bestDuration = duration;\r\n            bestPath = path;\r\n        }\r\n    });\r\n\r\n    return { \r\n        duration: bestDuration,\r\n        path: bestPath,\r\n    };\r\n};\r\n\r\nexport const findOptimalPath = (): AppThunkAction => (dispatch, getState) => {\r\n    const state = getState();\r\n    const waypoints = getWaypoints(state);\r\n    const pairRoutes = getPairRoutes(state);\r\n\r\n    let startWaypoint = Object.keys(waypoints)[0];\r\n    Object.entries(waypoints).forEach(([id, waypoint]) => {\r\n        if (waypoint.start) {\r\n            startWaypoint = id;\r\n        }\r\n    });\r\n\r\n    const { path } = optimalPathRecursion({\r\n        pairRoutes,\r\n        waypoints,\r\n        usedWaypoints: [startWaypoint],\r\n    });\r\n\r\n    dispatch(updateOptimalPath(path));\r\n};\r\n","import {\r\n    ApiKeyChangedAction,\r\n    ApiLoadedAction,\r\n    AppStartedLoadingAction,\r\n    AppFinishedLoadingAction,\r\n    API_KEY_CHANGED,\r\n    API_LOADED,\r\n    APP_STARTED_LOADING,\r\n    APP_FINISHED_LOADING,\r\n} from './types';\r\n\r\nexport const setApiKey = (key: string): ApiKeyChangedAction => ({\r\n    type: API_KEY_CHANGED,\r\n    payload: { apiKey: key },\r\n});\r\n\r\nexport const setApiLoaded = (): ApiLoadedAction => ({\r\n    type: API_LOADED,\r\n});\r\n\r\nexport const appStartLoading = (): AppStartedLoadingAction => ({\r\n    type: APP_STARTED_LOADING,\r\n});\r\n\r\nexport const appFinishLoading = (): AppFinishedLoadingAction => ({\r\n    type: APP_FINISHED_LOADING,\r\n});\r\n","import styled, { createGlobalStyle } from 'styled-components';\r\n\r\nexport const GlobalStyle = createGlobalStyle`\r\n    * {\r\n        margin: 0;\r\n        padding: 0;\r\n        outline: none;\r\n    }\r\n\r\n    html {\r\n        position: relative;\r\n        width: 100vw;\r\n        height: 100vh;\r\n    }\r\n\r\n    body {\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        right: 0;\r\n        bottom: 0;\r\n        -webkit-tap-highlight-color:  rgba(255, 255, 255, 0); \r\n    }\r\n\r\n    #root {\r\n        width: 100%;\r\n        height: 100%;\r\n        background-color: black;\r\n    }\r\n`;\r\n","import styled from 'styled-components';\r\n\r\nexport const MapContainer = styled.div`\r\n    height: 100vh;\r\n    width: 100%auto;\r\n`;\r\n\r\ninterface GoogleMapsPoint {\r\n    lat: number;\r\n    lng: number;\r\n    text?: string;\r\n}\r\n\r\nexport const WaypointElement = styled.div<GoogleMapsPoint>`\r\n    width: 20px;\r\n    height: 20px;\r\n    background-color: orange;\r\n    border-radius: 50%;\r\n\r\n    color: black;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n`;\r\n\r\nexport const WalkingRouteElement = styled.div<GoogleMapsPoint>`\r\n    width: 3px;\r\n    height: 3px;\r\n    background-color: blue;\r\n    border-radius: 50%;\r\n`;\r\n\r\nexport const TransportRouteElement = styled.div<GoogleMapsPoint>`\r\n    width: 3px;\r\n    height: 3px;\r\n    background-color: red;\r\n    border-radius: 50%;\r\n`;\r\n","import { connect } from 'react-redux';\r\nimport { createStructuredSelector } from 'reselect';\r\nimport GoogleMap from 'google-map-react';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { State, Waypoint, PairRoutes, TravelType } from '../../redux/types';\r\nimport { getApiKey, getWaypoints, getPairRoutes, getOptimalPath } from '../../redux/selectors';\r\nimport { MapContainer, WalkingRouteElement, TransportRouteElement, WaypointElement } from './style';\r\n\r\ninterface StateProps {\r\n    apiKey: string | null;\r\n    waypoints: Record<string, Waypoint>;\r\n    pairRoutes: PairRoutes;\r\n    optimalPath: string[];\r\n}\r\n\r\nconst Map: React.FC<StateProps> = ({ apiKey, waypoints, pairRoutes, optimalPath }) => {\r\n    const googleMapProps = {\r\n        bootstrapURLKeys: {\r\n            key: apiKey as string,\r\n        },\r\n        defaultCenter: {\r\n            lat: 55.75209773472255,\r\n            lng: 37.6174710947241,\r\n        },\r\n        defaultZoom: 12,\r\n    };\r\n\r\n    let allPathCoords: any[] = [];\r\n    Object.values(pairRoutes).forEach(pairRoute => {\r\n        Object.values(pairRoute).forEach(x => {\r\n            allPathCoords = [...allPathCoords, ...x.pathCoords];\r\n        });\r\n    });\r\n\r\n    let optimalPathCoords: Array<{ type: TravelType, lat: number, lng: number }> = [];\r\n    if (optimalPath.length > 1) {\r\n        for (let i = 1; i < optimalPath.length; ++i) {\r\n            const route = pairRoutes[optimalPath[i - 1]][optimalPath[i]];\r\n            route.pathCoords.forEach(coords => {\r\n                optimalPathCoords.push({ type: route.travelType, lat: coords.lat, lng: coords.lng });\r\n            });\r\n        }\r\n    }\r\n\r\n    return (\r\n        <MapContainer>\r\n            {apiKey ? (\r\n                <GoogleMap {...googleMapProps}>\r\n                    {optimalPathCoords.map(({ type, lat, lng }) => (\r\n                        type === TravelType.Walking ? (\r\n                            <WalkingRouteElement key={uuidv4()} lat={lat} lng={lng} />\r\n                        ) : (\r\n                            <TransportRouteElement key={uuidv4()} lat={lat} lng={lng} />\r\n                        )\r\n                    ))}\r\n                    {Object.entries(waypoints).map(([id, waypoint]) => (\r\n                        <WaypointElement key={id} lat={waypoint.lat} lng={waypoint.lng} text={waypoint.name}>\r\n                            {waypoint.name}\r\n                        </WaypointElement>\r\n                    ))}\r\n                </GoogleMap>\r\n            ) : null}\r\n        </MapContainer>\r\n    );\r\n};\r\n\r\nexport default connect<StateProps, {} ,{}, State>(\r\n    createStructuredSelector({\r\n        apiKey: getApiKey,\r\n        waypoints: getWaypoints,\r\n        pairRoutes: getPairRoutes,\r\n        optimalPath: getOptimalPath,\r\n    }),\r\n)(Map);\r\n","import { AppBar as MaterialAppBar, CircularProgress, IconButton, Toolbar, Typography } from '@material-ui/core';\r\nimport { Menu, Add, VpnKey, Search } from '@material-ui/icons';\r\n\r\ninterface AppBarProps {\r\n    isLoading?: boolean;\r\n    onMenuButtonClick: () => void;\r\n    onKeyButtonClick: () => void;\r\n    onAddButtonClick: () => void;\r\n    onSearchButtonClick: () => void;\r\n}\r\n\r\nconst AppBar: React.FC<AppBarProps> = ({ isLoading, onMenuButtonClick, onSearchButtonClick, onKeyButtonClick, onAddButtonClick }) => (\r\n    <MaterialAppBar color=\"default\">\r\n        <Toolbar>\r\n            <IconButton edge=\"start\" onClick={onMenuButtonClick}>\r\n                <Menu />\r\n            </IconButton>\r\n            <Typography variant=\"h6\">Pathfinder</Typography>\r\n\r\n            <div style={{ flex: 1 }} />\r\n\r\n            {isLoading ? (\r\n                <CircularProgress />\r\n            ) : (\r\n                <IconButton edge=\"end\" onClick={onSearchButtonClick}>\r\n                    <Search />\r\n                </IconButton>\r\n            )}\r\n            <IconButton edge=\"end\" onClick={onKeyButtonClick}>\r\n                <VpnKey />\r\n            </IconButton>\r\n            <IconButton edge=\"end\" onClick={onAddButtonClick}>\r\n                <Add />\r\n            </IconButton>\r\n        </Toolbar>\r\n    </MaterialAppBar>\r\n);\r\n\r\nexport default AppBar;\r\n","import { useState } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Button, Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle, Divider, Drawer, List, ListItem, Typography } from '@material-ui/core';\r\nimport { clearWaypoints } from '../../redux/actions';\r\nimport { getPairRoutes, getOptimalPath, getWaypoints } from '../../redux/selectors';\r\nimport { PairRoutes, Waypoint, State, TravelType } from '../../redux/types';\r\nimport { createStructuredSelector } from 'reselect';\r\n\r\ninterface OwnProps {\r\n    isVisible: boolean;\r\n    onClose: () => void;\r\n}\r\n\r\ninterface StateProps {\r\n    waypoints: Record<string, Waypoint>;\r\n    pairRoutes: PairRoutes;\r\n    optimalPath: string[];\r\n}\r\n\r\ninterface DispatchProps {\r\n    clearWaypoints: () => void;\r\n}\r\n\r\ntype SidebarProps = OwnProps & StateProps & DispatchProps;\r\n\r\nconst formatSeconds = (seconds: number) => {\r\n    const hours = Math.floor(seconds / 3600);\r\n    const minutes = Math.floor((seconds % 3600) / 60);\r\n\r\n    return `${hours}h ${minutes}m`;\r\n};\r\n\r\nconst Sidebar: React.FC<SidebarProps> = ({ isVisible, onClose, waypoints, pairRoutes, optimalPath, clearWaypoints }) => {\r\n    const [isClearDialogOpen, setIsClearDialogOpen] = useState(false);\r\n\r\n    const handleClear = () => {\r\n        clearWaypoints();\r\n        setIsClearDialogOpen(false);\r\n    };\r\n\r\n    let waypointList: JSX.Element[] = [];\r\n    if (optimalPath.length > 1) {\r\n        waypointList.push(\r\n            <ListItem key={optimalPath[0]}>\r\n                <Typography variant=\"body1\" color=\"primary\">{waypoints[optimalPath[0]].name} (Start)</Typography>\r\n            </ListItem>\r\n        );\r\n\r\n        for (let i = 1; i < optimalPath.length; ++i) {\r\n            const route = pairRoutes[optimalPath[i - 1]][optimalPath[i]];\r\n\r\n            waypointList.push(\r\n                <>\r\n                    <Divider key={`${optimalPath[i]}-1`} />\r\n                    <ListItem key={`${optimalPath[i]}-2`}>\r\n                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>\r\n                            <Typography variant=\"body2\">{formatSeconds(route.travelDuration)}</Typography>\r\n                            <Typography variant=\"body2\">{route.travelType === TravelType.Walking ? 'Walking' : 'Public Transport'}</Typography>\r\n                        </div>\r\n                    </ListItem>\r\n                    <Divider key={`${optimalPath[i]}-3`} />\r\n                    <ListItem key={`${optimalPath[i]}-4`}>\r\n                        <Typography variant=\"body1\" color=\"primary\">{waypoints[optimalPath[i]].name}{waypoints[optimalPath[i]].finish ? ' (Finish)' : ''}</Typography>\r\n                    </ListItem>\r\n                </>\r\n            );\r\n        }\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <Drawer anchor=\"left\" open={isVisible} onClose={onClose}>\r\n                <div style={{ width: '80vw', height: '0px' }} />\r\n                {optimalPath.length > 1 ? (\r\n                    <>\r\n                        <List>\r\n                            <ListItem>\r\n                                <Typography variant=\"h6\">Path</Typography>\r\n                            </ListItem>\r\n                            <Divider />\r\n                        </List>\r\n\r\n                        {waypointList}\r\n\r\n                        <Divider />\r\n                    </>\r\n                ) : null}\r\n\r\n                <Button onClick={() => setIsClearDialogOpen(true)}>Clear waypoints</Button>\r\n            </Drawer>\r\n\r\n            <Dialog open={isClearDialogOpen} onClose={() => setIsClearDialogOpen(false)}>\r\n                <DialogTitle>\r\n                    Confirm deletion\r\n                </DialogTitle>\r\n                <DialogContent>\r\n                    <DialogContentText>Are you sure you want to clear all waypoints?</DialogContentText>\r\n                </DialogContent>\r\n                <DialogActions>\r\n                    <Button color=\"default\" onClick={() => setIsClearDialogOpen(false)}>Cancel</Button>\r\n                    <Button color=\"secondary\" onClick={handleClear}>Confirm</Button>\r\n                </DialogActions>\r\n            </Dialog>\r\n        </>\r\n    );\r\n};\r\n\r\nexport default connect<StateProps, DispatchProps, OwnProps, State>(\r\n    createStructuredSelector({\r\n        waypoints: getWaypoints,\r\n        pairRoutes: getPairRoutes,\r\n        optimalPath: getOptimalPath,\r\n    }),\r\n    {\r\n        clearWaypoints,\r\n    }\r\n)(Sidebar);","import { useState, useEffect } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { createStructuredSelector } from 'reselect';\r\nimport {\r\n    Dialog,\r\n    DialogTitle,\r\n    DialogContent,\r\n    TextField,\r\n    DialogActions,\r\n    Button,\r\n} from '@material-ui/core';\r\nimport { State } from '../../redux/types';\r\nimport { getApiKey } from '../../redux/selectors';\r\nimport { setApiKey } from '../../redux/actions';\r\n\r\ninterface OwnProps {\r\n    isOpen: boolean;\r\n    onClose: () => void;\r\n}\r\n\r\ninterface StateProps {\r\n    apiKey: string | null;\r\n}\r\n\r\ninterface DispatchProps {\r\n    setApiKey: (key: string) => void;\r\n}\r\n\r\ntype ApiKeyDialogProps = OwnProps & StateProps & DispatchProps;\r\n\r\nconst ApiKeyDialog: React.FC<ApiKeyDialogProps> = ({ isOpen, onClose, apiKey, setApiKey }) => {\r\n    const [enteredApiKey, setEnteredApiKey] = useState(apiKey || '');\r\n\r\n    useEffect(() => {\r\n        setEnteredApiKey(apiKey || '');\r\n    }, [isOpen, apiKey]);\r\n\r\n    const handleApiKeyDialogConfirmed = () => {\r\n        setApiKey(enteredApiKey);\r\n\r\n        if (apiKey !== null && enteredApiKey !== apiKey) {\r\n            setTimeout(() => window.location.reload(), 100);\r\n        }\r\n\r\n        onClose();\r\n    };\r\n\r\n    return (\r\n        <Dialog fullWidth open={isOpen} onClose={onClose}>\r\n            <DialogTitle>Enter API key</DialogTitle>\r\n            <DialogContent>\r\n                <TextField value={enteredApiKey} onChange={e => setEnteredApiKey(e.target.value)} placeholder=\"API Key\" fullWidth />\r\n            </DialogContent>\r\n            <DialogActions>\r\n                <Button color=\"primary\" disabled={!enteredApiKey} onClick={handleApiKeyDialogConfirmed}>Confirm</Button>\r\n            </DialogActions>\r\n        </Dialog>\r\n    );\r\n};\r\n\r\nexport default connect<StateProps, DispatchProps, OwnProps, State>(\r\n    createStructuredSelector({\r\n        apiKey: getApiKey,\r\n    }),\r\n    {\r\n        setApiKey,\r\n    },\r\n)(ApiKeyDialog);\r\n","import { useState, useEffect } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { v4 as uuid } from 'uuid';\r\nimport {\r\n    Dialog,\r\n    DialogTitle,\r\n    DialogContent,\r\n    TextField,\r\n    DialogActions,\r\n    Button,\r\n    FormControlLabel,\r\n    Checkbox,\r\n} from '@material-ui/core';\r\nimport { State, Waypoint } from '../../redux/types';\r\nimport { addWaypointAndUpdatePairRoutes } from '../../redux/actions';\r\n\r\ninterface OwnProps {\r\n    isOpen: boolean;\r\n    onClose: () => void;\r\n}\r\n\r\ninterface DispatchProps {\r\n    addWaypointAndUpdatePairRoutes: (id: string, waypoint: Waypoint) => void;\r\n}\r\n\r\ntype AddWaypointDialogProps = OwnProps & DispatchProps;\r\n\r\nconst AddWaypointDialog: React.FC<AddWaypointDialogProps> = ({ isOpen, onClose, addWaypointAndUpdatePairRoutes }) => {\r\n    const [enteredName, setEnteredName] = useState('');\r\n    const [enteredCoords, setEnteredCoords] = useState('');\r\n    const [isStart, setIsStart] = useState(false);\r\n    const [isFinish, setIsFinish] = useState(false);\r\n\r\n    useEffect(() => {\r\n        setEnteredName('');\r\n        setEnteredCoords('');\r\n        setIsStart(false);\r\n        setIsFinish(false);\r\n    }, [isOpen]);\r\n\r\n    const handleAddWaypointDialogConfirmed = () => {\r\n        addWaypointAndUpdatePairRoutes(uuid(), {\r\n            name: enteredName,\r\n            lat: parseFloat(enteredCoords.split(',')[0]),\r\n            lng: parseFloat(enteredCoords.split(',')[1]),\r\n            start: isStart,\r\n            finish: isFinish,\r\n        });\r\n        onClose();\r\n    };\r\n\r\n    return (\r\n        <Dialog fullWidth open={isOpen} onClose={onClose}>\r\n            <DialogTitle>New waypoint</DialogTitle>\r\n            <DialogContent>\r\n                <TextField value={enteredName} onChange={e => setEnteredName(e.target.value)} label=\"Name\" fullWidth />\r\n                <TextField value={enteredCoords} onChange={e => setEnteredCoords(e.target.value)} label=\"Coordinates\" fullWidth />\r\n                <FormControlLabel control={<Checkbox color=\"primary\" checked={isStart} onChange={e => setIsStart(e.target.checked)} />} label=\"Start\" />\r\n                <FormControlLabel control={<Checkbox color=\"primary\" checked={isFinish} onChange={e => setIsFinish(e.target.checked)} />} label=\"Finish\" />\r\n            </DialogContent>\r\n            <DialogActions>\r\n                <Button onClick={onClose}>Cancel</Button>\r\n                <Button color=\"primary\" disabled={!(enteredName && enteredCoords)} onClick={handleAddWaypointDialogConfirmed}>Add</Button>\r\n            </DialogActions>\r\n        </Dialog>\r\n    );\r\n};\r\n\r\nexport default connect<{}, DispatchProps, OwnProps, State>(\r\n    null,\r\n    {\r\n        addWaypointAndUpdatePairRoutes,\r\n    },\r\n)(AddWaypointDialog);\r\n","import { useState, useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport { createStructuredSelector } from 'reselect';\nimport { Loader } from '@googlemaps/js-api-loader';\nimport { unstable_createMuiStrictModeTheme as createMuiTheme, ThemeProvider, CssBaseline } from '@material-ui/core';\nimport { orange } from '@material-ui/core/colors';\nimport { State } from './redux/types';\nimport { getApiKey, getIsApiLoaded, getIsAppLoading } from './redux/selectors';\nimport { setApiLoaded, findOptimalPath } from './redux/actions';\nimport { GlobalStyle } from './style';\nimport { Map, AppBar, Sidebar, ApiKeyDialog, AddWaypointDialog } from './components';\n\nconst theme = createMuiTheme({\n    palette: {\n        type: 'dark',\n        primary: {\n            main: orange['500'],\n        },\n    },\n});\n\ninterface StateProps {\n    apiKey: string | null;\n    isApiLoaded: boolean;\n    isLoading: boolean;\n}\n\ninterface DispatchProps {\n    setApiLoaded: () => void;\n    findOptimalPath: () => void;\n}\n\ntype AppProps = StateProps & DispatchProps;\n\nconst App: React.FC<AppProps> = ({ apiKey, isLoading, findOptimalPath, setApiLoaded }) => {\n    const [isSidebarVisible, setIsSidebarVisible] = useState(false);\n    const [isApiKeyDialogOpen, setIsApiKeyDialogOpen] = useState(false);\n    const [isAddWaypointDialogVisible, setIsAddWaypointDialogVisible] = useState(false);\n\n    useEffect(() => {\n        if (apiKey) {\n            const loader = new Loader({\n                apiKey,\n            });\n\n            loader.load().then(setApiLoaded);\n        }\n    }, [apiKey, setApiLoaded]);\n\n    return (\n        <ThemeProvider theme={theme}>\n            <GlobalStyle />\n            <CssBaseline />\n\n            <AppBar\n                onMenuButtonClick={() => setIsSidebarVisible(true)}\n                onKeyButtonClick={() => setIsApiKeyDialogOpen(true)}\n                onAddButtonClick={() => setIsAddWaypointDialogVisible(true)}\n                onSearchButtonClick={findOptimalPath}\n                isLoading={isLoading}\n            />\n            <Sidebar isVisible={isSidebarVisible} onClose={() => setIsSidebarVisible(false)} />\n\n            <Map />\n\n            <ApiKeyDialog isOpen={isApiKeyDialogOpen} onClose={() => setIsApiKeyDialogOpen(false)} />\n            <AddWaypointDialog isOpen={isAddWaypointDialogVisible} onClose={() => setIsAddWaypointDialogVisible(false)} />\n        </ThemeProvider>\n    );\n};\n\nexport default connect<StateProps, DispatchProps, {}, State>(\n    createStructuredSelector({\n        apiKey: getApiKey,\n        isApiLoaded: getIsApiLoaded,\n        isLoading: getIsAppLoading,\n    }),\n    {\n        setApiLoaded,\n        findOptimalPath,\n    }\n)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === '[::1]' ||\n        // 127.0.0.0/8 are considered localhost for IPv4.\n        window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                            'worker. To learn more, visit https://cra.link/PWA'\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then((registration) => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                    'tabs for this page are closed. See https://cra.link/PWA.'\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch((error) => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n        headers: { 'Service-Worker': 'script' },\n    })\n        .then((response) => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then((registration) => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log('No internet connection found. App is running in offline mode.');\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready\n            .then((registration) => {\n                registration.unregister();\n            })\n            .catch((error) => {\n                console.error(error.message);\n            });\n    }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n            getCLS(onPerfEntry);\n            getFID(onPerfEntry);\n            getFCP(onPerfEntry);\n            getLCP(onPerfEntry);\n            getTTFB(onPerfEntry);\n        });\n    }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/lib/integration/react';\nimport { persistor, store } from './redux';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <Provider store={store}>\n            <PersistGate persistor={persistor} loading={<p>loading</p>}>\n                <App />\n            </PersistGate>\n        </Provider>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","export interface Waypoint {\r\n    name: string;\r\n    lat: number;\r\n    lng: number;\r\n    start: boolean;\r\n    finish: boolean;\r\n}\r\n\r\nexport enum TravelType {\r\n    Walking = 'Walking',\r\n    PublicTransport = 'PublicTransport',\r\n}\r\n\r\nexport interface PairRoute {\r\n    travelDuration: number;\r\n    travelType: TravelType;\r\n    pathCoords: Array<{ lat: number; lng: number }>;\r\n}\r\n\r\nexport type PairRoutes = Record<string, Record<string, PairRoute>>;\r\n\r\nexport interface WaypointsState {\r\n    waypoints: Record<string, Waypoint>;\r\n    pairRoutes: PairRoutes;\r\n    optimalPath: string[];\r\n}\r\n\r\nexport const WAYPOINT_ADDED = 'WAYPOINT_ADDED';\r\nexport const WAYPOINT_REMOVED = 'WAYPOINT_REMOVED';\r\nexport const PAIR_ROUTES_UPDATED = 'PAIR_ROUTES_UPDATED';\r\nexport const OPTIMAL_PATH_UPDATED = 'OPTIMAL_PATH_UPDATED';\r\nexport const WAYPOINTS_CLEARED = 'WAYPOINTS_CLEARED';\r\n\r\nexport interface WaypointAddedAction {\r\n    type: typeof WAYPOINT_ADDED;\r\n    payload: {\r\n        id: string;\r\n        waypoint: Waypoint;\r\n    };\r\n}\r\n\r\nexport interface WaypointRemovedAction {\r\n    type: typeof WAYPOINT_REMOVED;\r\n    payload: {\r\n        id: string;\r\n    };\r\n}\r\n\r\nexport interface PairRoutesUpdatedAction {\r\n    type: typeof PAIR_ROUTES_UPDATED;\r\n    payload: {\r\n        pairRoutes: PairRoutes;\r\n    };\r\n}\r\n\r\nexport interface OptimalPathUpdatedAction {\r\n    type: typeof OPTIMAL_PATH_UPDATED;\r\n    payload: {\r\n        optimalPath: string[]\r\n    };\r\n}\r\n\r\nexport interface WaypointsClearedAction {\r\n    type: typeof WAYPOINTS_CLEARED;\r\n}\r\n\r\nexport type WaypointsAction = WaypointAddedAction | WaypointRemovedAction | PairRoutesUpdatedAction | OptimalPathUpdatedAction | WaypointsClearedAction;\r\n","export interface SettingsState {\r\n    apiKey: string | null;\r\n    getIsApiLoaded: boolean;\r\n    isLoading: boolean;\r\n}\r\n\r\nexport const API_KEY_CHANGED = 'API_KEY_CHANGED';\r\nexport const API_LOADED = 'API_LOADED';\r\nexport const APP_STARTED_LOADING = 'APP_STARTED_LOADING';\r\nexport const APP_FINISHED_LOADING = 'APP_FINISHED_LOADING';\r\n\r\nexport interface ApiKeyChangedAction {\r\n    type: typeof API_KEY_CHANGED;\r\n    payload: {\r\n        apiKey: string;\r\n    };\r\n}\r\n\r\nexport interface ApiLoadedAction {\r\n    type: typeof API_LOADED;\r\n}\r\n\r\nexport interface AppStartedLoadingAction {\r\n    type: typeof APP_STARTED_LOADING;\r\n}\r\n\r\nexport interface AppFinishedLoadingAction {\r\n    type: typeof APP_FINISHED_LOADING;\r\n}\r\n\r\nexport type SettingsAction = ApiKeyChangedAction | ApiLoadedAction | AppStartedLoadingAction | AppFinishedLoadingAction;\r\n","export * from './state/types';\r\nexport * from './state/settings/types';\r\nexport * from './state/waypoints/types';\r\n"],"sourceRoot":""}